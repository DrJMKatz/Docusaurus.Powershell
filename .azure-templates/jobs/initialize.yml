# -----------------------------------------------------------------------------
# Initializes the Gitversion devops task.
#
# Please note that this step ONLY works on a 'windows-2019' image.
# -----------------------------------------------------------------------------

parameters:
  updateAssemblyInfo: false
  additionalArguments: ''

jobs:
  - job: Initialize
    pool:
      vmImage: 'windows-2019'

    steps:
    - template: ../steps/log-virtual-machine-information.yml

    # log template parameters
    - powershell: |
        Write-Host "updateAssemblyInfo  = ${{ parameters.updateAssemblyInfo }}"
        Write-Host "additionalArguments = ${{ parameters.additionalArguments }}"
      displayName: 'Template Parameters'

    # checkout files from large file system
    # https://docs.microsoft.com/en-us/azure/devops/pipelines/repos/pipeline-options-for-git?view=azure-devops#checkout-files-from-lfs
    - checkout: self
      lfs: true

    # export the original git commit message before gitversion changes it so we can add it to the
    # variables artifact and use it as a condition during the Publish stage
    - powershell: |
        $commitMessage = git log -1 --pretty=%B
        Write-Host "commit message = $commitMessage"
      displayName: 'Export Commit Message'

    # run the gitversion Devops task
    - task: gittools.gitversion.gitversion-task.GitVersion@5
      displayName: GitVersion
      inputs:
        updateAssemblyInfo: ${{ parameters.updateAssemblyInfo }}
        additionalArguments: ${{ parameters.additionalArguments }}

    # export variables so they can be used by jobs WITHIN the same stage
    - powershell: |
        @{
            Counter          = '$(GitVersion.MajorMinorPatch)'
            SafeBranchName   = '$(GitVersion.BranchName)' -replace '[\\/]','-'
            SubModuleCount   = @(git submodule foreach :).Count
            HasSolutionFile  = Test-Path *.sln
            HasProjectFile   = Test-Path *.*proj
            HasDotNetProject = (Test-Path *.csproj, *.fsproj, *.sln) -contains $true
        }.GetEnumerator().ForEach({
            Write-Host ("EXPORT {0} = {1}`n##vso[task.setvariable variable={0};isOutput=true]{1}" -f $_.Key, $_.Value)
        })
      name: Output
      displayName: Export ModuleBuilder Variables


    # we also create a variables directory so we can use an artifact to share variables between stages
    # see: https://medium.com/microsoftazure/how-to-pass-variables-in-azure-pipelines-yaml-tasks-5c81c5d31763
    - powershell: |
        $variableDir = Join-Path -Path $(Pipeline.Workspace) -ChildPath "moduleBuilderVariables"
        New-Item -Path $variableDir -ItemType Directory -Verbose
        Add-Content -Path (Join-Path -Path $variableDir -ChildPath "Counter") -Value '$(Output.Counter)'
        Add-Content -Path (Join-Path -Path $variableDir -ChildPath "CommitMessage") -Value '$(COMMIT_MESSAGE)'
      name: PrepareArtifact
      displayName: Prepare Variables Artifact

    # publish the variables artifact
    - publish: $(Pipeline.Workspace)/moduleBuilderVariables
      artifact: ModuleBuilderVariables
      name: PublishArtifact
      displayName: Publish Variables Artifact
